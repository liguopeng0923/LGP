import torch
import torch.nn as nn

from mmrotate.core.bbox import rbbox_overlaps
from mmdet.core import multi_apply
from adv.builder import ATTACK_METHODS

from adv.utils.DWT import *
from adv.utils.FBS import *


@ATTACK_METHODS.register_module()
class attackBase(nn.Module):

    def __init__(self,
                 num_iteration: int =50,
                 model = None,
                 alpha: float = 1,
                 beta: float = 1,
                 gamma: float = 1,
                 miu: float = 0.1,
                 single_stage: bool = False,
                 adv_labels: int = -1,
                 fore_scale:float = 1.0,
                 wh_scale: float = 3,
                 iou_cond:int = 10,
                 score_cond:int = 10,
                 optimizer = None,
                 iouLoss = None,
                 clsLoss = None,
                 regLoss = None,
                 advPerLoss = None,
                 wave: str = 'haar'
                 ) -> None:
        """Regression attacking to object detection which aims at the rpn or roi or network outputs.

        Args:
            num_iteration (int, optional): Iteration of the attacking process. Defaults to 15.
            device (torch.device, optional): The gpu to run the attacking. Defaults to torch.device('cuda').
            alpha (float, optional): The weight of first cost generated by xyaLoss. Defaults to 1.
            beta (float, optional): The weight of second cost generated by whLoss. Defaults to 1.
            gamma (float, optional): The weight of third cost generated by advPerLoss. Defaults to 0.1.
            adv_labels (int, optional): The labels of target adversarial examples. Defaults to -1.optional: -1 background,1 first label,2 second label.
            fore_scale (float, optional): The foreground bboxes scale to limit the distribution of perturbation. Defaults to 1.5.
            iou_cond (int, optional): The number of adv_bboxes belongs to every ground truth. Defaults to 15.
            score_cond (float, optional): The score threhold of adv_bboxes. Defaults to 200.
            optimizer (_type_, optional): The optimizer of grad. Defaults to None.
            advPerLoss (_type_, optional): The loss function to reduce the perceptibility of the adversarial perturbation. Defaults to None.
            wave:str='haar'. The type of wave.
        """
        super(attackBase, self).__init__()
        self.num_iteration = num_iteration
        self.model = model
        self.device = model.device
        self.alpha = alpha
        self.beta = beta
        self.gamma = gamma
        self.miu = miu
        self.single_stage = single_stage
        if not type(adv_labels) == int:
            adv_labels = -1
        self.adv_labels = adv_labels
        self.fore_scale = fore_scale
        self.score_cond = score_cond
        self.iou_cond = iou_cond
        self.wh_scale = wh_scale
        
        self.optimizer= optimizer if optimizer else dict(type='Adamax',lr=0.1,weight_decay=0.02)
        self.regLoss = regLoss if regLoss else dict(type='SmoothL1Loss',reduction = "mean")
        self.clsLoss = clsLoss if clsLoss else dict(type='LogitLossAdv',reduction='sum')
        self.iouLoss = iouLoss if iouLoss else dict(type='RotatedIoULoss', loss_weight=1.0)
        self.advPerLoss = advPerLoss if advPerLoss else dict(type='SmoothL1Loss', beta=1.0, loss_weight=1.0,reduction='sum')
        self.wave = wave
        self.DWT = DWT_2D_tiny(wavename= self.wave)
        self.IDWT = IDWT_2D_tiny(wavename= self.wave)
        self._losses = torch.zeros(num_iteration).unsqueeze(0).repeat(5,1)
        self._bboxes = torch.zeros(num_iteration)
        self._labels = {"total_loss":'b-',"reg_loss":'g:',"iou_loss":"r-","cls_loss":'r--',"adv_per_loss":'c-.'}

    def _get_targets(
        self,
        gt_bboxes,
        proposal_bboxes,
        proposal_scores,
        iou_cond,
        score_cond
    ):
        bboxes_by_iou,scores_by_iou = multi_apply(self._select_bboxes_iou_single,gt_bboxes,proposal_bboxes,proposal_scores,iou_cond=iou_cond)
        
        bboxes_by_score,scores_by_score = multi_apply(self._select_bboxes_score_single,gt_bboxes,proposal_bboxes,proposal_scores,score_cond=score_cond)
        bboxes = [torch.cat([iou,score],dim=1) for iou,score in zip(bboxes_by_iou,bboxes_by_score)]
        scores = [torch.cat([iou,score],dim=1) for iou,score in zip(scores_by_iou,scores_by_score)]
        
        return bboxes,scores
    
    # 给每个target_bboxes分配iou_cond条件下的predict_bboxes
    # TODO ,为得分高的分配gt
    def _select_bboxes_iou_single(
        self,
        target_bboxes,
        predict_bboxes,
        predict_scores,
        iou_cond,
    ):
        assert isinstance(iou_cond,int)
        device = target_bboxes.device
        
        iou_cond = torch.min(torch.tensor([iou_cond,len(predict_bboxes)])).int().item()
        
        iou_bboxes = rbbox_overlaps(target_bboxes,predict_bboxes,mode = "iou")
        
        paired_ious, paired_idx = torch.sort(iou_bboxes,dim = -1,descending = True)
        
        bboxes = predict_bboxes[paired_idx]
        bboxes = bboxes[:,:iou_cond,:]
        scores = predict_scores[paired_idx]
        scores = scores[:,:iou_cond,:]
        return bboxes,scores
    
    def _select_bboxes_score_single(
        self,
        target_bboxes,
        predict_bboxes,
        predict_scores,
        score_cond,
    ):
        assert isinstance(score_cond,int)
        device = target_bboxes.device
        gt_nums = target_bboxes.shape[0]
        num_class = predict_scores.shape[1]
        background_label = predict_scores.shape[1] - 1
        
        first_score, first_label = torch.max(predict_scores,dim = -1)
        
        first_score = first_score[first_label != background_label]
        
        foreground_bboxes = predict_bboxes[first_label != background_label]
        foreground_scores = predict_scores[first_label != background_label]
        paried_scores, paried_scores_idx = torch.sort(first_score,dim = -1, descending = True)
        foreground_bboxes = foreground_bboxes[paried_scores_idx]
        foreground_scores = foreground_scores[paried_scores_idx]
        
        iou_bboxes = rbbox_overlaps(foreground_bboxes,target_bboxes,mode = "iou")
        paired_ious, paired_ious_idx = torch.max(iou_bboxes,dim = -1)
        
        nums_iou = torch.bincount(paired_ious_idx)
        nums_iou = nums_iou[nums_iou > 0]
        if not nums_iou.numel():
            score_cond = 0
        else:
            score_cond = torch.min(torch.tensor([score_cond,torch.min(nums_iou)])).int().item()
        
        bboxes = torch.zeros((gt_nums,score_cond,predict_bboxes.shape[-1])).to(device=device)
        scores = torch.zeros((gt_nums,score_cond,predict_scores.shape[-1])).to(device=device)
        for i in range(gt_nums):
            mask = (paired_ious_idx == i).any()
            if not mask:
            # TODO 更好的分配策略
                bboxes[i,:score_cond,:] = target_bboxes[i].unsqueeze(0).repeat(score_cond,1)
                background_scores = torch.ones((score_cond,num_class)) * (- 1e10)
                background_scores[:,-1] = 1
                background_scores = torch.softmax(background_scores,dim=-1)
                scores[i,:score_cond,:] = background_scores
            else:
                bboxes[i,:score_cond,:] = foreground_bboxes[paired_ious_idx == i][:score_cond]
                scores[i,:score_cond,:] = foreground_scores[paired_ious_idx == i][:score_cond]
        return bboxes,scores
    
    
    def losses_log(self,n=1):
        result = f"total_loss = {self.losses[0] / n},\nreg_loss = {self.losses[1] / n},\niou_loss = {self.losses[2] / n},\ncls_loss = {self.losses[3] / n},\nadv_per_loss = {self.losses[4] / n}"
        return result
    
    @property
    def losses(self):
        return self._losses
    @property
    def bboxes(self):
        return self._bboxes
    @property
    def labels(self):
        return self._labels
    